<!DOCTYPE html>
<html>
<head>
    <title>Line chart - Visual Vocabulary</title>
    <script src="//d3js.org/d3.v4.js"></script>
    <script src="//d3js.org/d3-selection-multi.v1.min.js"></script>
    <script src="//financial-times.github.io/g-chartframe/build/g-chartframe.js"></script>
    <script src="//ft-interactive.github.io/visual-vocabulary/shared/svg2png.js"></script>
    <script src="//ft-interactive.github.io/g-chartcolour/build/g-chartcolour.js"></script>
    <script src="lineChart.js"></script>
    <script src="legend.js"></script>

    <link rel="stylesheet" href="https://www.ft.com/__origami/service/build/v2/bundles/css?modules=o-fonts@^2.2.0" />
    <link rel="stylesheet" href="styles.css"/>
    <style>
    .saveable button{ display: block; }
    </style>
</head>
<body>

    <h1>Line chart</h1>
    <p>A suggested starting point new charts types in the visual vocab.</p>
    <hr>
    <figure class="framed saveable" data-frame="web"><svg></svg></figure>
    <figure class="framed saveable" data-frame="print"><svg></svg></figure>
    <figure class="framed saveable" data-frame="social"><svg></svg></figure>
    <figure class="framed saveable" data-frame="video"><svg></svg></figure>

</body>

<script type="text/javascript">

//User defined constants
const sharedConfig = {
  title:"Title not yet added",
  subtitle:"Subtitle not yet added",  
  source:"Fox news",
}
let yMin = 0;
let yMax = 1500;
const yAxisHighlight = 100;
const numTicksy = 3;
const yAxisAlign = "right";
const interval = "years"
let markers = false;
let legendAlign = "vert"//hori or vert
let minorAxis = false

const frame = {
   web: gChartframe.webFrame(sharedConfig)
   .margin({right:0}),
   print: gChartframe.printFrame(sharedConfig)
   .margin({right:0}),
   social: gChartframe.socialFrame(sharedConfig)
   .margin({right:0}),
   video: gChartframe.videoFrame(sharedConfig)
   .margin({right:0}),
};


//add the frames to the page...
d3.selectAll('.framed')
    .each(function(){
        const figure = d3.select(this);
        figure.select('svg')
            .call(frame[figure.node().dataset.frame]);
    });

d3.csv('example.csv', function(data){
    //draw your charts! (see the slope chart for example)
    var parseDate = d3.timeParse("%d/%m/%Y")
    
    data.forEach(function(d) {
                d.date=parseDate(d.date);
            });

    let seriesNames=getSeriesNames(data.columns)
    let plotData=seriesNames.map(function(d,i){
        return {
            name:d,
            lineData:getlines(data,d)
        }
    })
    //console.log(plotData)
    const boundries=data.filter((d)=> (d.marker==="begin" || d.marker==="end"))
    let highlights=[]
    boundries.forEach(function(d,i){
        if (d.marker==="begin") {
            highlights.push({begin: d.date,end:boundries[i+1].date}) 
        }
    })
   //console.log("highlights", highlights)
    
    const valueExtent = extentMulti(data,seriesNames)

    const myChart = lineChart()
        .seriesNames(seriesNames)
        .yDomain([Math.min(yMin,valueExtent[0]),Math.max(yMax,valueExtent[1])])
        .xDomain(d3.extent(data, function(d) {return d.date;}))
        .yAxisAlign(yAxisAlign)
        .markers(markers)

    Object.keys(frame).forEach(frameName=>{

        const myYAxis = yLinearAxis();
        const myXAxis = xDateAxis();
        const myHighlights = drawHighlights()
        const myLegend = drawLegend()
        const currentFrame = frame[frameName];
        const plotDim=currentFrame.dimension()
        const tickSize=plotDim.width;

        //console.log(plotData)
    
        myChart
            .yRange( [currentFrame.dimension().height,0] )
            .plotDim(plotDim)
            .rem(currentFrame.rem())
            .includeMarker((d)=> (d.marker==="yes"))
            .colourPalette((frameName));
        
        myYAxis
            .yScale(myChart.yScale())
            .numTicksy(numTicksy)
            .tickSize(tickSize)
            .yAxisHighlight(yAxisHighlight)
            .yAxisAlign(myChart.yAxisAlign())

        currentFrame.plot()
            .call(myYAxis);
        
        //console.log("Labels offset ",myYAxis.yLabelOffset())
        //add code to redraw frame with new right margin to come.

        //Pass new range based on new margin
        myChart.xRange( [0,currentFrame.dimension().width] );

        myXAxis
            .xScale(myChart.xScale())
            .plotDim(myChart.plotDim())
            .interval(interval)
            .rem(myChart.rem())
            .minorAxis(minorAxis);;

        myHighlights
            .yScale(myChart.yScale())
            .yRange( [currentFrame.dimension().height,0] )
            .xScale(myChart.xScale())
            .xRange( [0,currentFrame.dimension().width] );

        currentFrame.plot()
            .selectAll(".highlights")
            .data(highlights)
            .enter()
            .append("g")
            .call(myHighlights);
        
        currentFrame.plot()
            .call(myXAxis);

        currentFrame.plot()
            .selectAll("lines")
            .data(plotData)
            .enter()
            .append("g")
            .attr('class','lines')
            .call(myChart);
        
        myLegend
            .seriesNames(seriesNames)
            .colourPalette((frameName))
            .rem(myChart.rem())
            .alignment(legendAlign);

        currentFrame.plot()
            .selectAll(".legend")
            .data(seriesNames)
            .enter()
            .append("g")
            .classed("legend",true)
            .call(myLegend)

     });
});

//a function that returns the columns headers from the top of the dataset, excluding specified
function getSeriesNames(columns){
    var exclude = ['date','annotate','marker'];
    return columns.filter(d=>(exclude.indexOf(d) == -1));
}

//a function to work out the extent of values in an array accross multiple properties...
function extentMulti(data, columns){
    const ext = data.reduce((acc, row, index)=>{
        let values = columns.map(key=> +row[key])
        let rowExtent = d3.extent(values);
        if(!acc.max){
            acc.max = rowExtent[1];
            acc.min = rowExtent[0];
        }else{
            acc.max = Math.max(acc.max, rowExtent[1]);
            acc.min = Math.min(acc.min, rowExtent[0]);
        }
        return acc;
    },{});
    return [ext.min, ext.max];
}

function getlines(data,group) {
    let lineData=[]
    data.forEach(function(el,i){
        //console.log(el,i)
        let column=new Object();
        column.name = group
        column.date = el.date
        column.value = +el[group]
        column.marker = el.marker
        column.annotate = el.annotate
        if(el[group]) {
            lineData.push(column)  
        } 
    });
    return lineData
}


</script>
</html>